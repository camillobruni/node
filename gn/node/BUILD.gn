# Copyright (c) 2013-2019 GitHub Inc.
# Copyright 2019 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//node/node_files.gni")
import("//v8/gni/v8.gni")

declare_args() {
  # Enable the V8 inspector protocol for use with node.
  node_enable_inspector = !is_fuchsia

  # Build node with SSL support.
  # The variable is called "openssl" for parity with node's GYP build.
  node_use_openssl = true

  # Use the specified path to system CA (PEM format) in addition to
  # the BoringSSL supplied CA store or compiled-in Mozilla CA copy.
  node_openssl_system_ca_path = ""

  # Initialize v8 platform during node.js startup.
  node_use_v8_platform = true

  # Build with DTrace support.
  node_use_dtrace = false

  # Build with ETW support.
  node_use_etw = false

  # Build JavaScript in lib/ with DCHECK macros.
  node_debug_lib = false

  # Custom build tag.
  node_tag = ""

  # V8 options to pass, see `node --v8-options` for examples.
  node_v8_options = ""

  # Provide a custom URL prefix for the `process.release` properties
  # `sourceUrl` and `headersUrl`. When compiling a release build, this will
  # default to https://nodejs.org/download/release/').
  node_release_urlbase = ""

  # Use code cache to speed up startup.
  node_use_code_cache = !is_win && !is_fuchsia

  # Use snapshot to speed up startup.
  node_use_snapshot = !is_win && !is_fuchsia
}

assert(!node_use_dtrace, "node_use_dtrace not supported in GN")
assert(!node_use_etw, "node_use_etw not supported in GN")

assert(!node_enable_inspector || node_use_openssl,
       "node_enable_inspector requires node_use_openssl")

template("chdir_action") {
  action(target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "script",
                             "args",
                           ])
    assert(defined(cwd), "Need cwd in $target_name")
    script = "//tools/run_in_dir.py"
    if (defined(sources)) {
      sources += [ invoker.script ]
    } else {
      assert(defined(inputs))
      inputs += [ invoker.script ]
    }
    args = [
      rebase_path(cwd),
      rebase_path(invoker.script),
    ]
    args += invoker.args
  }
}

copy("node_js2c_inputs") {
  sources = node_files.node_library_files
  outputs = [
    "$target_gen_dir/js2c_inputs/{{source_target_relative}}",
  ]
}

action("generate_config_gypi") {
  script = "//tools/generate_config_gypi.py"
  outputs = [
    "$target_gen_dir/js2c_inputs/config.gypi",
  ]
  depfile = "$target_gen_dir/$target_name.d"

  if (is_mac) {
    gn = "//buildtools/mac/gn"
  } else if (is_win) {
    gn = "//buildtools/win/gn.exe"
  } else {
    gn = "//buildtools/linux64/gn"
  }
  script_args = [
    gn,
    "$root_out_dir",
  ]
  script_args += outputs
  script_args += [ depfile ]
  args = rebase_path(script_args, root_build_dir)
}

chdir_action("node_js2c") {
  deps = [
    ":generate_config_gypi",
    ":node_js2c_inputs",
  ]

  macro_inputs = []
  config_gypi = [ "$target_gen_dir/js2c_inputs/config.gypi" ]

  # We use a relative path to work around an assertion in js2c.py.
  config_gypi_relative_path = [ "config.gypi" ]

  library_files = node_files.all_library_files
  inputs =
      get_target_outputs(":node_js2c_inputs") +
      macro_inputs + config_gypi
  outputs = [
    "$target_gen_dir/node_javascript.cc",
  ]

  cwd = "$target_gen_dir/js2c_inputs"
  script = "tools/js2c.py"
  args = [ "--target" ] + rebase_path(outputs)
  args += library_files
  args += rebase_path(macro_inputs) + config_gypi_relative_path
}

config("node_base_external") {
  include_dirs = [ "src" ]
  defines = [ "NODE_WANT_INTERNALS=1" ]
  configs = [ "//v8:external_config" ]
}

config("node_base_internal") {
  visibility = [
    ":*",
    "src/inspector:*",
  ]
  configs = [ ":node_base_external" ]
  cflags = [ "-Wno-microsoft-include" ]
  libs = []
  cflags_cc = [
    "-Wno-deprecated-declarations",
    "-Wno-implicit-fallthrough",
    "-Wno-return-type",
    "-Wno-sometimes-uninitialized",
    "-Wno-unused-label",
    "-Wno-unused-private-field",
    "-Wno-unused-variable",
    "-Wno-string-plus-int",
    "-Wno-string-conversion",
    "-Wno-unused-function",
    "-Wno-extra-semi",  # Temporarily until resolved upstream.
    "-Wno-unreachable-code" # node_crypto.cc has unreachable code.
  ]

  if (target_cpu == "x86") {
    node_arch = "ia32"
  } else {
    node_arch = target_cpu
  }
  if (target_os == "win") {
    node_platform = "win32"
  } else if (target_os == "mac") {
    node_platform = "darwin"
  } else {
    node_platform = target_os
  }
  defines = [
    "NODE_ARCH=\"$node_arch\"",
    "NODE_PLATFORM=\"$node_platform\"",
    "NODE_REPORT"
  ]

  if (is_win) {
    defines += [
      "NOMINMAX",
      "_UNICODE=1",
    ]
    libs += [ "psapi.lib" ]
  } else {
    defines += [ "__POSIX__" ]
  }
  if (is_mac) {
    libs += [ "CoreFoundation.framework" ]
  }
  if (node_tag != "") {
    defines += [ "NODE_TAG=\"$node_tag\"" ]
  }
  if (node_v8_options != "") {
    defines += [ "NODE_V8_OPTIONS=\"$node_v8_options\"" ]
  }
  if (node_release_urlbase != "") {
    defines += [ "NODE_RELEASE_URLBASE=\"$node_release_urlbase\"" ]
  }
  if (node_use_openssl) {
    defines += [
      "NODE_OPENSSL_SYSTEM_CERT_PATH=\"$node_openssl_system_ca_path\"",
      "HAVE_OPENSSL=1",
    ]
  } else {
    defines += [ "HAVE_OPENSSL=0" ]
  }
  if (node_use_v8_platform) {
    defines += [ "NODE_USE_V8_PLATFORM=1" ]
  } else {
    defines += [ "NODE_USE_V8_PLATFORM=0" ]
  }
  if (node_enable_inspector) {
    defines += [ "HAVE_INSPECTOR=1" ]
  } else {
    defines += [ "HAVE_INSPECTOR=0" ]
  }
  if (v8_enable_i18n_support) {
    defines += [ "NODE_HAVE_I18N_SUPPORT=1" ]
  } else {
    defines += [ "NODE_HAVE_I18N_SUPPORT=0" ]
  }
}

source_set("node_base") {
  deps = [
    ":node_js2c",
    "deps/brotli/c:brotli",
    "deps/cares",
    "deps/histogram",
    "deps/llhttp",
    "deps/nghttp2",
    "deps/uvwasi",
    "//third_party/zlib",
    "//v8:v8_libplatform",
  ]
  public_deps = [
    "deps/uv",
    "//v8",
  ]
  public_configs = [
    ":node_base_external",
    "//build/config/compiler:no_chromium_code",
  ]
  if (is_posix || is_mac || is_fuchsia) {
    public_configs += [ "//build/config/gcc:symbol_visibility_default" ]
    configs -= [ "//build/config/gcc:symbol_visibility_hidden" ]
  }
  configs += [ ":node_base_internal" ]
  configs -= [ "//build/config/clang:find_bad_constructs" ]

  sources = node_files.node_sources
  sources += [ "$target_gen_dir/node_javascript.cc" ]

  if (v8_enable_i18n_support) {
    deps += [ "//third_party/icu" ]
  }

  if (node_enable_inspector) {
    deps += [ "src/inspector" ]
  }

  if (node_use_openssl) {
    deps += [ "deps/openssl" ]
    sources += node_files.crypto_sources
  }
}

if (node_use_code_cache) {
  executable("node_mkcodecache") {
    sources = [
      "src/node_code_cache_stub.cc",
      "src/node_snapshot_stub.cc",
      "tools/code_cache/cache_builder.cc",
      "tools/code_cache/cache_builder.h",
      "tools/code_cache/mkcodecache.cc",
    ]
    configs += [ ":node_base_internal" ]
    deps = [
      ":node_base",
    ]
  }

  action("run_node_mkcodecache") {
    script = "//tools/run_executable_in_dir.py"
    base = target_gen_dir
    stamp = "$target_gen_dir/run_mkcodecache.stamp"
    exe = "$root_out_dir/node_mkcodecache"
    output_cc = "$target_gen_dir/node_code_cache.cc"
    outputs = [
      stamp,
      output_cc,
    ]
    args = [
      rebase_path(base, root_build_dir),
      rebase_path(stamp, root_build_dir),
      rebase_path(exe, base),
      rebase_path(output_cc, base),
    ]
    deps = [
      ":node_mkcodecache",
    ]
  }
}

if (node_use_snapshot) {
  executable("node_mksnapshot") {
    sources = [
      "src/node_code_cache_stub.cc",
      "src/node_snapshot_stub.cc",
      "tools/snapshot/node_mksnapshot.cc",
      "tools/snapshot/snapshot_builder.cc",
      "tools/snapshot/snapshot_builder.h",
    ]
    configs += [ ":node_base_internal" ]
    deps = [
      ":node_base",
    ]
  }

  action("run_node_mksnapshot") {
    script = "//tools/run_executable_in_dir.py"
    base = target_gen_dir
    stamp = "$target_gen_dir/run_node_mksnapshot.stamp"
    exe = "$root_out_dir/node_mksnapshot"
    output_cc = "$target_gen_dir/node_snapshot.cc"
    outputs = [
      stamp,
      output_cc,
    ]
    args = [
      rebase_path(base, root_build_dir),
      rebase_path(stamp, root_build_dir),
      rebase_path(exe, base),
      rebase_path(output_cc, base),
    ]
    deps = [
      ":node_mksnapshot",
    ]
  }
}

component("node_lib") {
  sources = [
    "src/node_main.cc",
  ]
  public_deps = [
    ":node_base",
  ]
  deps = []
  if (node_use_code_cache) {
    sources += [ "$target_gen_dir/node_code_cache.cc" ]
    deps += [ ":run_node_mkcodecache" ]
  } else {
    sources += [ "src/node_code_cache_stub.cc" ]
  }
  if (node_use_snapshot) {
    sources += [ "$target_gen_dir/node_snapshot.cc" ]
    deps += [ ":run_node_mksnapshot" ]
  } else {
    sources += [ "src/node_snapshot_stub.cc" ]
  }
  output_name = "node"
}

executable("node") {
  sources = [
    "src/node_main.cc",
  ]
  deps = [
    ":node_lib",
  ]
}

source_set("gtest_main") {
  testonly = true
  include_dirs = [ "test/cctest" ]
  sources = [
    "test/cctest/gtest/gtest.h",
    "test/cctest/gtest/gtest-all.cc",
    "test/cctest/gtest/gtest_main.cc",
  ]
  deps = [ "deps/uv" ]
  if (is_fuchsia) {
    deps += [
      "//third_party/fuchsia-sdk/sdk/pkg/fdio",
      "//third_party/fuchsia-sdk/sdk/pkg/zx"
    ]
  }
}

executable("node_cctest") {
  testonly = true
  deps = [
    ":node_base",
    ":gtest_main",
  ]
  configs += [ ":node_base_internal" ]
  sources = node_files.cctest_sources
  if (node_enable_inspector) {
    sources += [
      "test/cctest/test_inspector_socket.cc",
      "test/cctest/test_inspector_socket_server.cc",
    ]
  }
}
